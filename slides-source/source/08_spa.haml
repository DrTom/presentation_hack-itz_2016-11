
%section#spa_into
  %h1 ðŸ•–  Single Page Applications

  %blockquote
    Single-Page Applications (SPAs) are Web apps that load a single HTML page
    and dynamically update that page as the user interacts with the app ...
    without constant page reloads. (ASP.NET)

  %small.text-muted
    We consider a webapp without data exchange to or from the server for now.


%section#spa_reframe
  :markdown
    # [re-frame](https://github.com/Day8/re-frame)

    _re-frame_ is a **pattern** for writing SPAs in **ClojureScript**, using **Reagent**.

    > "It's MVC, Jim, but not as we know it". (re-frame)

  .fragment

    %p
      %b.text-warning Honestly, it is not MVC!

    %small
      :markdown
        You will find the patterns used in _re-frame_ in other talks, libraries, frameworks.
        It is all over the place.

        You should read the re-frame documentation. It is witty in all of its meanings.



%section#spa_reframe_key
  %h1 re-frame key features
  .row
    .col-xs-6
      :markdown
        ![re-frame](re-frame.png){: width="80%"}

    .col-xs-6
      :markdown
        * One and only one database!

        * Data flows from the database to the DOM.

        * Events cause the database to change.

        * Events never manipulate the DOM directly.

        **no shortcuts!**
        {: .text-warning}



%section#spa_databases
  :markdown
    # One Database ?

    Technically, you can have multiple databases.

    Their signal graph must form an **acyclic directed graph**.

    Make sure you don't shortcut. The Dom is always "the sink".

    Do not complicate things unnecessarily
    â‡’ **just use one database**!
    {: .text-info}

  %small.fragment.text-muted

    These rules are less out of a technical necessity.  They help us to avoid
    unnecessary complexity and focus on the features.






%section#spa_validation
  :markdown
    # Define a Schema and Validate!

    ~~~clojure
    (ns cider-ci.repository.fetch-and-update.db-schema
      (:require [schema.core :as schema]))

    (def schema
      {:last_fetched_at (schema/maybe org.joda.time.DateTime)
       :last_error (schema/maybe String)
       :last_error_at (schema/maybe org.joda.time.DateTime)
       :updated_at org.joda.time.DateTime
       :state (schema/enum "error" "fetching" "initializing" "ok" "waiting")
       :pending? Boolean })
    ~~~

  .fragment
    :markdown
      e.g. use it like this

      ~~~clojure
      (def fetch-and-update-db
        (atom {:last_fetched_at nil
               :last_error nil
               :last_error_at nil
               :updated_at (time/now)
               :pending? true
               :state "initializing" }
              :validator #(schema/validate schema %)))
      ~~~

    %small
      :markdown
        [plumatic/schema](https://github.com/plumatic/schema) works uniformly in Clojure and ClojureScript.


